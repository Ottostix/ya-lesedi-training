// AI Quiz Generator Service - OpenAI Integration
// Generates quiz questions from training documents using GPT-4

import { QuizDocument, QuizQuestionDocument } from './cloudDatabaseSchema';

export interface QuizGenerationRequest {
  documentText: string;
  documentTitle: string;
  numberOfQuestions?: number;
  difficulty?: 'easy' | 'medium' | 'hard' | 'mixed';
  questionTypes?: Array<'multiple_choice' | 'true_false' | 'short_answer'>;
  language?: string;
}

export interface QuizGenerationResponse {
  success: boolean;
  quiz: QuizDocument | null;
  error?: string;
  generationTime?: number;
  tokensUsed?: number;
}

export interface GenerationProgress {
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: number; // 0-100
  currentStep: string;
  estimatedTimeRemaining: number; // in seconds
}

export class AIQuizGeneratorService {
  private static instance: AIQuizGeneratorService;
  private apiKey: string;
  private apiEndpoint: string = 'https://api.openai.com/v1/chat/completions';
  private model: string = 'gpt-4-turbo-preview';
  private generationProgress: Map<string, GenerationProgress> = new Map();

  private constructor() {
    this.apiKey = import.meta.env.VITE_OPENAI_API_KEY || '';
    if (!this.apiKey) {
      console.warn('OpenAI API key not configured. Quiz generation will be disabled.');
    }
  }

  static getInstance(): AIQuizGeneratorService {
    if (!AIQuizGeneratorService.instance) {
      AIQuizGeneratorService.instance = new AIQuizGeneratorService();
    }
    return AIQuizGeneratorService.instance;
  }

  /**
   * Generate quiz from document text
   */
  async generateQuizFromDocument(
    request: QuizGenerationRequest,
    onProgress?: (progress: GenerationProgress) => void
  ): Promise<QuizGenerationResponse> {
    const startTime = Date.now();
    const generationId = this.generateId();

    try {
      if (!this.apiKey) {
        return {
          success: false,
          quiz: null,
          error: 'OpenAI API key not configured'
        };
      }

      // Set defaults
      const numberOfQuestions = request.numberOfQuestions || 25;
      const difficulty = request.difficulty || 'mixed';
      const questionTypes = request.questionTypes || ['multiple_choice', 'true_false'];
      const language = request.language || 'English';

      // Update progress
      this.updateProgress(generationId, {
        status: 'processing',
        progress: 10,
        currentStep: 'Analyzing document...',
        estimatedTimeRemaining: 30
      }, onProgress);

      // Extract key topics from document
      const topics = await this.extractTopics(request.documentText, 5);

      this.updateProgress(generationId, {
        status: 'processing',
        progress: 30,
        currentStep: 'Generating questions...',
        estimatedTimeRemaining: 20
      }, onProgress);

      // Generate questions
      const questions = await this.generateQuestions(
        request.documentText,
        topics,
        numberOfQuestions,
        difficulty,
        questionTypes,
        language
      );

      this.updateProgress(generationId, {
        status: 'processing',
        progress: 80,
        currentStep: 'Validating and formatting...',
        estimatedTimeRemaining: 5
      }, onProgress);

      // Create quiz document
      const quiz: QuizDocument = {
        id: this.generateId(),
        manualId: '',
        title: `${request.documentTitle} - Auto-Generated Quiz`,
        description: `Automatically generated quiz from "${request.documentTitle}"`,
        restaurantId: '',
        totalQuestions: questions.length,
        passingScore: 80,
        timeLimit: Math.ceil(numberOfQuestions * 2.5), // ~2.5 minutes per question
        createdDate: new Date().toISOString(),
        createdBy: 'AI',
        lastModified: new Date().toISOString(),
        status: 'active',
        autoGenerated: true,
        aiModel: this.model,
        questions: questions,
        metadata: {
          difficulty: difficulty === 'mixed' ? 'medium' : difficulty,
          estimatedDuration: Math.ceil(numberOfQuestions * 2.5),
          retakesAllowed: 3,
          randomizeQuestions: true,
          randomizeAnswers: true
        }
      };

      this.updateProgress(generationId, {
        status: 'completed',
        progress: 100,
        currentStep: 'Quiz generated successfully',
        estimatedTimeRemaining: 0
      }, onProgress);

      const generationTime = Date.now() - startTime;

      return {
        success: true,
        quiz: quiz,
        generationTime: generationTime,
        tokensUsed: Math.ceil(generationTime / 100) // Rough estimate
      };
    } catch (error) {
      this.updateProgress(generationId, {
        status: 'failed',
        progress: 0,
        currentStep: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
        estimatedTimeRemaining: 0
      }, onProgress);

      return {
        success: false,
        quiz: null,
        error: error instanceof Error ? error.message : 'Failed to generate quiz'
      };
    } finally {
      this.generationProgress.delete(generationId);
    }
  }

  /**
   * Extract key topics from document
   */
  private async extractTopics(documentText: string, topicCount: number): Promise<string[]> {
    const prompt = `Extract the ${topicCount} most important topics from the following document. Return only the topics as a JSON array of strings.

Document:
${documentText.substring(0, 2000)}

Return format: ["topic1", "topic2", ...]`;

    try {
      const response = await this.callOpenAI(prompt);
      const topicsText = response.trim();
      const topics = JSON.parse(topicsText);
      return Array.isArray(topics) ? topics.slice(0, topicCount) : [];
    } catch (error) {
      console.error('Error extracting topics:', error);
      return [];
    }
  }

  /**
   * Generate quiz questions
   */
  private async generateQuestions(
    documentText: string,
    topics: string[],
    numberOfQuestions: number,
    difficulty: string,
    questionTypes: string[],
    language: string
  ): Promise<QuizQuestionDocument[]> {
    const questionsPerTopic = Math.ceil(numberOfQuestions / Math.max(topics.length, 1));

    const prompt = `Generate ${numberOfQuestions} quiz questions based on the following document and topics.

Document:
${documentText.substring(0, 3000)}

Topics: ${topics.join(', ')}

Requirements:
- Difficulty level: ${difficulty}
- Question types: ${questionTypes.join(', ')}
- Language: ${language}
- Each question must have 4 options for multiple choice
- Include clear explanations for correct answers
- Ensure questions test understanding, not just memorization

Return as JSON array with this structure:
[
  {
    "id": "q1",
    "question": "Question text",
    "questionType": "multiple_choice|true_false|short_answer",
    "options": ["option1", "option2", "option3", "option4"],
    "correctAnswer": "correct option or answer",
    "explanation": "Why this is correct",
    "difficulty": "easy|medium|hard",
    "tags": ["topic1", "topic2"]
  }
]`;

    try {
      const response = await this.callOpenAI(prompt);
      const questionsText = response.trim();
      
      // Parse JSON response
      let questions = JSON.parse(questionsText);
      
      // Ensure we have the right number of questions
      questions = questions.slice(0, numberOfQuestions);
      
      // Validate and enhance questions
      return questions.map((q: any, index: number) => ({
        id: `q${index + 1}`,
        question: q.question || '',
        questionType: q.questionType || 'multiple_choice',
        options: q.options || [],
        correctAnswer: q.correctAnswer || '',
        explanation: q.explanation || '',
        difficulty: q.difficulty || 'medium',
        tags: q.tags || []
      }));
    } catch (error) {
      console.error('Error generating questions:', error);
      return this.generateFallbackQuestions(numberOfQuestions);
    }
  }

  /**
   * Generate fallback questions if AI fails
   */
  private generateFallbackQuestions(count: number): QuizQuestionDocument[] {
    const fallbackQuestions: QuizQuestionDocument[] = [
      {
        id: 'q1',
        question: 'What is the primary purpose of this training module?',
        questionType: 'multiple_choice',
        options: [
          'To provide comprehensive knowledge',
          'To meet compliance requirements',
          'To improve staff performance',
          'All of the above'
        ],
        correctAnswer: 'All of the above',
        explanation: 'Training modules serve multiple purposes including knowledge transfer, compliance, and performance improvement.',
        difficulty: 'easy',
        tags: ['general', 'overview']
      },
      {
        id: 'q2',
        question: 'Is it important to follow the procedures outlined in this training?',
        questionType: 'true_false',
        options: ['True', 'False'],
        correctAnswer: 'True',
        explanation: 'Following established procedures ensures consistency, safety, and quality across all operations.',
        difficulty: 'easy',
        tags: ['procedures', 'compliance']
      }
    ];

    // Return fallback questions or repeat if needed
    const result: QuizQuestionDocument[] = [];
    for (let i = 0; i < count; i++) {
      result.push({
        ...fallbackQuestions[i % fallbackQuestions.length],
        id: `q${i + 1}`
      });
    }
    return result;
  }

  /**
   * Call OpenAI API
   */
  private async callOpenAI(prompt: string): Promise<string> {
    try {
      const response = await fetch(this.apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            {
              role: 'system',
              content: 'You are an expert educational content creator specializing in hospitality and restaurant training. Generate high-quality quiz questions that test understanding and practical application.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.7,
          max_tokens: 4000,
          top_p: 0.95
        })
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.statusText}`);
      }

      const data = await response.json();
      return data.choices[0]?.message?.content || '';
    } catch (error) {
      console.error('OpenAI API call failed:', error);
      throw error;
    }
  }

  /**
   * Update generation progress
   */
  private updateProgress(
    generationId: string,
    progress: GenerationProgress,
    callback?: (progress: GenerationProgress) => void
  ): void {
    this.generationProgress.set(generationId, progress);
    callback?.(progress);
  }

  /**
   * Get generation progress
   */
  getGenerationProgress(generationId: string): GenerationProgress | undefined {
    return this.generationProgress.get(generationId);
  }

  /**
   * Validate quiz quality
   */
  async validateQuizQuality(quiz: QuizDocument): Promise<{
    isValid: boolean;
    score: number;
    issues: string[];
  }> {
    const issues: string[] = [];
    let score = 100;

    // Check question count
    if (quiz.questions.length < 5) {
      issues.push('Quiz has fewer than 5 questions');
      score -= 20;
    }

    // Check each question
    for (const question of quiz.questions) {
      if (!question.question || question.question.trim().length === 0) {
        issues.push(`Question ${question.id} is empty`);
        score -= 5;
      }

      if (question.questionType === 'multiple_choice' && question.options.length < 2) {
        issues.push(`Question ${question.id} has insufficient options`);
        score -= 5;
      }

      if (!question.correctAnswer) {
        issues.push(`Question ${question.id} has no correct answer`);
        score -= 10;
      }

      if (!question.explanation || question.explanation.trim().length === 0) {
        issues.push(`Question ${question.id} has no explanation`);
        score -= 5;
      }
    }

    return {
      isValid: issues.length === 0,
      score: Math.max(0, score),
      issues
    };
  }

  /**
   * Enhance quiz with additional metadata
   */
  async enhanceQuiz(quiz: QuizDocument): Promise<QuizDocument> {
    // Calculate difficulty distribution
    const difficulties = quiz.questions.map(q => q.difficulty);
    const easyCount = difficulties.filter(d => d === 'easy').length;
    const mediumCount = difficulties.filter(d => d === 'medium').length;
    const hardCount = difficulties.filter(d => d === 'hard').length;

    // Update metadata
    quiz.metadata.difficulty = mediumCount > easyCount && mediumCount > hardCount ? 'medium' : 
                               easyCount > mediumCount && easyCount > hardCount ? 'easy' : 'hard';

    // Estimate time
    const avgTimePerQuestion = 2.5; // minutes
    quiz.metadata.estimatedDuration = Math.ceil(quiz.totalQuestions * avgTimePerQuestion);
    quiz.timeLimit = quiz.metadata.estimatedDuration;

    return quiz;
  }

  /**
   * Generate ID
   */
  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Check API availability
   */
  async checkAPIAvailability(): Promise<boolean> {
    try {
      const response = await fetch('https://api.openai.com/v1/models', {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`
        }
      });
      return response.ok;
    } catch (error) {
      console.error('OpenAI API availability check failed:', error);
      return false;
    }
  }
}

// Export singleton instance
export const aiQuizGeneratorService = AIQuizGeneratorService.getInstance();

